{"version":3,"sources":["webpack:///./node_modules/@writewithocto/ink/dist/es/ttcn-cfg-e4d75048.js"],"names":["words","str","obj","split","i","length","curPunc","parserConfig","name","keywords","fileNCtrlMaskOptions","externalCommands","multiLineStrings","isOperatorChar","tokenBase","stream","state","ch","next","tokenize","tokenString","test","skipToEnd","eatWhile","cur","current","propertyIsEnumerable","quote","escaped","end","afterNext","peek","toLowerCase","Context","indented","column","type","align","prev","this","pushContext","col","indent","context","popContext","t","ttcnCfg","startState","startOfLine","token","ctx","sol","indentation","eatSpace","style","languageData","indentOnInput","commentTokens","line"],"mappings":"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","file":"js/chunk-2d221df8.cd83e4f4.js","sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i)\n    obj[words[i]] = true;\n  return obj;\n}\n\nconst parserConfig = {\n  name: \"ttcn-cfg\",\n  keywords: words(\"Yes No LogFile FileMask ConsoleMask AppendFile\" +\n                  \" TimeStampFormat LogEventTypes SourceInfoFormat\" +\n                  \" LogEntityName LogSourceInfo DiskFullAction\" +\n                  \" LogFileNumber LogFileSize MatchingHints Detailed\" +\n                  \" Compact SubCategories Stack Single None Seconds\" +\n                  \" DateTime Time Stop Error Retry Delete TCPPort KillTimer\" +\n                  \" NumHCs UnixSocketsEnabled LocalAddress\"),\n  fileNCtrlMaskOptions: words(\"TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING\" +\n                              \" TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP\" +\n                              \" TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION\" +\n                              \" TTCN_USER TTCN_FUNCTION TTCN_STATISTICS\" +\n                              \" TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG\" +\n                              \" EXECUTOR ERROR WARNING PORTEVENT TIMEROP\" +\n                              \" VERDICTOP DEFAULTOP TESTCASE ACTION USER\" +\n                              \" FUNCTION STATISTICS PARALLEL MATCHING DEBUG\" +\n                              \" LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED\" +\n                              \" DEBUG_ENCDEC DEBUG_TESTPORT\" +\n                              \" DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE\" +\n                              \" DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT\" +\n                              \" DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED\" +\n                              \" EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA\" +\n                              \" EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS\" +\n                              \" EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED\" +\n                              \" FUNCTION_RND FUNCTION_UNQUALIFIED\" +\n                              \" MATCHING_DONE MATCHING_MCSUCCESS\" +\n                              \" MATCHING_MCUNSUCC MATCHING_MMSUCCESS\" +\n                              \" MATCHING_MMUNSUCC MATCHING_PCSUCCESS\" +\n                              \" MATCHING_PCUNSUCC MATCHING_PMSUCCESS\" +\n                              \" MATCHING_PMUNSUCC MATCHING_PROBLEM\" +\n                              \" MATCHING_TIMEOUT MATCHING_UNQUALIFIED\" +\n                              \" PARALLEL_PORTCONN PARALLEL_PORTMAP\" +\n                              \" PARALLEL_PTC PARALLEL_UNQUALIFIED\" +\n                              \" PORTEVENT_DUALRECV PORTEVENT_DUALSEND\" +\n                              \" PORTEVENT_MCRECV PORTEVENT_MCSEND\" +\n                              \" PORTEVENT_MMRECV PORTEVENT_MMSEND\" +\n                              \" PORTEVENT_MQUEUE PORTEVENT_PCIN\" +\n                              \" PORTEVENT_PCOUT PORTEVENT_PMIN\" +\n                              \" PORTEVENT_PMOUT PORTEVENT_PQUEUE\" +\n                              \" PORTEVENT_STATE PORTEVENT_UNQUALIFIED\" +\n                              \" STATISTICS_UNQUALIFIED STATISTICS_VERDICT\" +\n                              \" TESTCASE_FINISH TESTCASE_START\" +\n                              \" TESTCASE_UNQUALIFIED TIMEROP_GUARD\" +\n                              \" TIMEROP_READ TIMEROP_START TIMEROP_STOP\" +\n                              \" TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED\" +\n                              \" USER_UNQUALIFIED VERDICTOP_FINAL\" +\n                              \" VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT\" +\n                              \" VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED\"),\n  externalCommands: words(\"BeginControlPart EndControlPart BeginTestCase\" +\n                          \" EndTestCase\"),\n  multiLineStrings: true\n};\n\nvar keywords = parserConfig.keywords,\n    fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions,\n    externalCommands = parserConfig.externalCommands,\n    multiLineStrings = parserConfig.multiLineStrings;\nvar isOperatorChar = /[\\|]/;\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (/[:=]/.test(ch)) {\n    curPunc = ch;\n    return \"punctuation\";\n  }\n  if (ch == \"#\"){\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  if (ch == \"[\"){\n    stream.eatWhile(/[\\w_\\]]/);\n    return \"number\";\n  }\n\n  stream.eatWhile(/[\\w\\$_]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))\n    return \"atom\";\n  if (externalCommands.propertyIsEnumerable(cur)) return \"deleted\";\n\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped){\n        var afterNext = stream.peek();\n        //look if the character if the quote is like the B in '10100010'B\n        if (afterNext){\n          afterNext = afterNext.toLowerCase();\n          if(afterNext == \"b\" || afterNext == \"h\" || afterNext == \"o\")\n            stream.next();\n        }\n        end = true; break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !(escaped || multiLineStrings))\n      state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n//Interface\nconst ttcnCfg = {\n  startState: function() {\n    return {\n      tokenize: null,\n      context: new Context(0, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n\n  token: function(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\") return style;\n    if (ctx.align == null) ctx.align = true;\n\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\")\n        && ctx.type == \"statement\"){\n      popContext(state);\n    }\n    else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n    else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n    else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n    else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n      if (ctx.type == \"}\") ctx = popContext(state);\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    }\n    else if (curPunc == ctx.type) popContext(state);\n    else if ((((ctx.type == \"}\" || ctx.type == \"top\")\n                                   && curPunc != ';') || (ctx.type == \"statement\"\n                                                          && curPunc == \"newstatement\")))\n      pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"#\"}\n  }\n};\n\nexport { ttcnCfg };\n"],"sourceRoot":""}