{"version":3,"sources":["webpack:///./node_modules/@writewithocto/ink/dist/es/index-e41426f6.js"],"names":["countCol","string","end","tabSize","startIndex","startValue","search","length","countColumn","slice","StringStream","indentUnit","this","pos","start","lastColumnPos","lastColumnValue","charAt","undefined","match","ok","ch","RegExp","test","eat","found","indexOf","n","pattern","consume","caseInsensitive","cased","str","toLowerCase","substr","index","fullParser","spec","token","blankLine","startState","copyState","defaultCopyState","indent","languageData","state","newState","prop","val","Array","StreamLanguage","parser","data","defineLanguageFacet","p","startParse","input","startPos","context","Parse","docID","indentService","of","cx","getIndent","streamParser","stateAfter","WeakMap","tree","syntaxTree","at","resolve","type","topNode","parent","statePos","findState","from","unit","line","doc","lineAt","Math","min","to","stream","text","readToken","exec","Language","lang","off","before","get","i","children","child","positions","Tree","cutTree","inside","inner","concat","findStartInFragments","fragments","f","offset","getIndentUnit","empty","chunks","chunkPos","chunk","chunkStart","push","viewport","skipUntilInView","parseLine","finishChunk","finish","lineAfter","eol","tokenID","build","buffer","nodeSet","topID","maxBufferLength","set","balance","result","Error","tokenTable","Object","create","typeArray","NodeType","none","NodeSet","warned","tag","createTokenType","legacyName","name","warnForPart","part","msg","console","warn","tagStr","split","value","tags","replace","define","id","props","styleTags","languageDataProp","add"],"mappings":"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","file":"js/chunk-2d2250ee.385e238d.js","sourcesContent":["import { c as countColumn, L as Language, d as defineLanguageFacet, i as indentService, s as syntaxTree, T as Tree, t as tags, N as NodeType, a as styleTags, l as languageDataProp, g as getIndentUnit, b as NodeSet } from './index-8d5ff86c.js';\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    return countColumn(string.slice(startIndex, end), startValue, tabSize);\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {}\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends Language {\n    constructor(parser) {\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser);\n        let startParse = (input, startPos, context) => new Parse(this, input, startPos, context);\n        super(data, { startParse }, docID(data), [indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        this.streamParser = p;\n        this.stateAfter = new WeakMap;\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.state.doc.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && lang.stateAfter.get(tree);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i] + from, child = tree.children[i], inner;\n        if (pos < to && child instanceof Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, state) {\n    for (let f of fragments) {\n        let found = f.from <= startPos && f.to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, f.to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(getIndentUnit(state)), tree: Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, startPos, context) {\n        this.lang = lang;\n        this.input = input;\n        this.startPos = startPos;\n        this.context = context;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        let { state, tree } = findStartInFragments(lang, context.fragments, startPos, context.state);\n        this.state = state;\n        this.pos = this.chunkStart = startPos + tree.length;\n        if (tree.length) {\n            this.chunks.push(tree);\n            this.chunkPos.push(0);\n        }\n        if (this.pos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.pos, context.viewport.from);\n            this.pos = context.viewport.from;\n        }\n    }\n    advance() {\n        let end = Math.min(this.context.viewport.to, this.input.length, this.chunkStart + 2048 /* ChunkSize */);\n        while (this.pos < end)\n            this.parseLine();\n        if (this.chunkStart < this.pos)\n            this.finishChunk();\n        if (end < this.input.length && this.pos < this.context.viewport.to)\n            return null;\n        this.context.skipUntilInView(this.pos, this.input.length);\n        return this.finish();\n    }\n    parseLine() {\n        let line = this.input.lineAfter(this.pos), { streamParser } = this.lang;\n        let stream = new StringStream(line, this.context ? this.context.state.tabSize : 4, getIndentUnit(this.context.state));\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    this.chunk.push(tokenID(token), this.pos + stream.start, this.pos + stream.pos, 4);\n            }\n        }\n        this.pos += line.length;\n        if (this.pos < this.input.length)\n            this.pos++;\n    }\n    finishChunk() {\n        let tree = Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.pos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */\n        });\n        this.lang.stateAfter.set(tree, this.lang.streamParser.copyState(this.state));\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.startPos);\n        this.chunk = [];\n        this.chunkStart = this.pos;\n    }\n    finish() {\n        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.pos - this.startPos).balance();\n    }\n    forceFinish() {\n        return this.finish();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst tokenTable = /*@__PURE__*/Object.create(null);\nconst typeArray = [NodeType.none];\nconst nodeSet = /*@__PURE__*/new NodeSet(typeArray);\nconst warned = [];\nfunction tokenID(tag) {\n    return !tag ? 0 : tokenTable[tag] || (tokenTable[tag] = createTokenType(tag));\n}\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    tokenTable[legacyName] = /*@__PURE__*/tokenID(name);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = tags[part];\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = NodeType.define({ id: typeArray.length, name: \"Document\", props: [languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexport { StreamLanguage, StringStream };\n"],"sourceRoot":""}